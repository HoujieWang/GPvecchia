#' evaluation of the likelihood
#'
#' @param vecchia.approx: a vecchia object as generated by vecchia_specify()
#' @param covparms: covariance parameters as a vector
#' @param nuggets: either a single (constant) nugget or a vector of nugget terms for the observations
#' @param covmodel: covariance model, 'matern' by default
#'
#' @return (multivariate normal) loglikelihood implied by the Vecchia approximation
#' @examples
#' z=rnorm(5); locs=matrix(1:5,ncol=1); vecchia.approx=vecchia_specify(locs,m=5)
#' vecchia_likelihood(z,vecchia.approx,covparms=c(1,2,.5),nuggets=.2)
#' @export
vecchia_likelihood=function(z,vecchia.approx,covparms,nuggets,covmodel='matern') {

  # create the U matrix
  U.obj=createU(vecchia.approx,covparms,nuggets,covmodel)


  # remove NAs in data and U
  na.rm()

  # compute the loglikelihood
  vecchia_likelihood_U(z,U.obj)
}


#' Wrapper for VL version of vecchia_likelihood
#'
#' @param vecchia.approx: a vecchia object as generated by vecchia_specify()
#' @param likelihood_model: text describing likelihood model to be used for observations
#' @param covparms: covariance parameters as a vector
#' @param likparms: likelihood parameters for the likelihood_model, as a list
#' @param covmodel: covariance model, 'matern' by default
#'
#' @return (multivariate normal) loglikelihood implied by the Vecchia approximation
#' @examples
#' z=rnorm(5); locs=matrix(1:5,ncol=1); vecchia.approx=vecchia_specify(locs,m=5)
#' vecchia_likelihood(z,vecchia.approx,covparms=c(1,2,.5),nuggets=.2)
#' @export
vecchia_laplace_likelihood<- function(z,vecchia.approx,likelihood_model, covparms,
                                      likparms = list("alpha"=2, "sigma"=sqrt(.1)),
                                      covmodel='matern', max.iter=50, convg = 1e-5,
                                      return_all = TRUE, y_init = NA,
                                      prior_mean = rep(0,length(z)),
                                      vecchia.approx.IW = NA) {

  # vecchia.approx.IW can be passed in for parameter estimation to reduce cpu time,
  posterior = calculate_posterior_VL(z,vecchia.approx, likelihood_model, covparms, likparms,
                         max.iter, convg, return_all, y_init, prior_mean)

  if(!posterior$cnvgd) return(-Inf)

  m = ncol(vecchia.approx$U.prep$revNNarray)-1
  locs = vecchia.approx$locsord[order(vecchia.approx$ord.z),]

  # get pseudodata and nuggets from the latent y discovered by VL
  z_pseudo = posterior$t
  nuggets_pseudo = posterior$D

  # create an approximation to llh using interweaved ordering.
  if(all(is.na(vecchia.approx.IW))){
    vecchia.approx.IW = vecchia.approx
    if(vecchia.approx$cond.yz == "zy"){
      vecchia.approx.IW = vecchia_specify(locs, m)
    }
  }
  pseudo_marginal_loglik_vecchia = vecchia_likelihood(z_pseudo, vecchia.approx.IW,
                                                      covparms,nuggets_pseudo, covmodel)

  # get true model log likelihood
  true_llh = posterior$true_llh

  # get gaussian (pseudo-data) approximate log likelihood
  pseudo_cond_loglik = sum(dnorm(z_pseudo,mean = posterior$mean, sd =sqrt(nuggets_pseudo), log = TRUE))

  # combine three log likelihood terms
  loglik_vecchia = pseudo_marginal_loglik_vecchia + true_llh - pseudo_cond_loglik

  return(loglik_vecchia)
}



## remove missing data (NA)
na.rm=function(){ # overwrites z and U.obj
  p = parent.frame()
  if(any(is.na(p$z))){
    ind.na=(((1:nrow(p$U.obj$U))[!p$U.obj$latent])[p$U.obj$ord.z])[is.na(p$z)]
    if(any(apply(p$U.obj$U[,ind.na,drop=FALSE],2,nnzero)>2)) stop(
      'NA data is conditioned upon')
    p$U.obj$U = p$U.obj$U[-ind.na,-ind.na]
    p$U.obj$latent = p$U.obj$latent[-ind.na]
    p$U.obj$ord.z = order(order(p$U.obj$ord.z[p$U.obj$ord.z %in% which(!is.na(p$z))]))
    p$z = p$z[!is.na(p$z)]
  }
}


## evaluate vecchia likelihood based on U

vecchia_likelihood_U=function(z,U.obj) {

  ### output: loglikelihood (for z)
  U=U.obj$U
  latent=U.obj$latent
  zord=z[U.obj$ord.z]

  # constant
  const=sum(!latent)*log(2*pi)

  # numerator
  z1=Matrix::crossprod(U[!latent,],zord)
  quadform.num=sum(z1^2)
  logdet.num=-2*sum(log(Matrix::diag(U)))

  # denominator
  U.y=U[latent,]
  z2=as.numeric(U.y%*%z1)
  V.ord=U2V(U.obj)
  z3=solve(V.ord,rev(z2),system='L')
  quadform.denom=sum(z3^2)
  logdet.denom=-2*sum(log(diag(V.ord)))

  # putting everything together
  neg2loglik=logdet.num-logdet.denom+quadform.num-quadform.denom+const
  loglik=-neg2loglik/2
  return(loglik)

}


## function to reverse-order a matrix
rev.mat=function(mat) mat[nrow(mat):1,ncol(mat):1,drop=FALSE]
