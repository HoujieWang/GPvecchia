#' Vecchia prediction
#'
#' @param vecchia.approx: a vecchia object as generated by vecchia_specify()
#' @param covparms: covariance parameters as a vector
#' @param nuggets: nugget
#' @param var.exact: should prediction variances be computed exactly, or is a (faster) approximation acceptable
#' @param covmodel: covariance model, 'matern' by default.
#' @param return.values: either 'mean' only, 'meanvar', 'meanmat', or 'all'
#'
#' @return posterior mean and variances at observed and unobserved locations; V matrix
#' @examples
#' z=rnorm(5); locs=matrix(1:5,ncol=1); vecchia_specify=function(locs,m=5,locs.pred=(1:5)+.5)
#' vecchia_prediction=function(z,vecchia.approx,covparms=c(1,2,.5),nuggets=.2)
#' @export

vecchia_prediction=function(z,vecchia.approx,covparms,nuggets,var.exact,
                            covmodel='matern',return.values='all') {

  # create the U matrix
  U.obj=createU(vecchia.approx,covparms,nuggets,covmodel)

  # remove NAs in data and U
  na.rm()

  # compute cholesky V for posterior inference
  V.ord=U2V(U.obj)

  if(length(U.obj$zero.nugg)>0)
    print('Warning: Rows/cols of V have been removed for data with zero noise')

  # compute the posterior mean
  vecchia.mean=vecchia_mean(z,vecchia.approx,U.obj,V.ord)

  # return what is requested
  return.list=list(mu.pred=vecchia.mean$mu.pred,mu.obs=vecchia.mean$mu.obs,
                   var.pred=NULL,var.obs=NULL,V.ord=NULL,U.obj=NULL)

  if(return.values=='meanmat' | return.values=='all'){
    return.list$V.ord=V.ord; return.list$U.obj=U.obj
  }

  if(return.values=='meanvar' | return.values=='all'){

    # compute posterior variances
    if(missing(var.exact)) var.exact = (sum(!vecchia.approx$obs)<4*1e4)
    vars.vecchia=vecchia_var(U.obj,V.ord,exact=var.exact)

    return.list$var.pred=vars.vecchia$vars.pred
    return.list$var.obs=vars.vecchia$vars.obs

  }

  return(return.list)

}



######  wrapper for VL version w/pseudo-data   #######

vecchia_laplace_prediction=function(vl_posterior, vecchia.approx, covparms, var.exact,
                                    covmodel='matern',return.values='all') {
  # perform vecchia_prediction with pseudo-data
  z_pseudo = vl_posterior$t
  nuggets_pseudo = vl_posterior$D
  preds=vecchia_prediction(z_pseudo, vecchia.approx, covparms, nuggets_pseudo,
                           TRUE, covmodel, return.values)
  data_preds = list()

  # Convert predicted mean (median) to data scale
  data_preds$data.pred <- vl_posterior$data_link(preds$mu.pred)
  data_preds$data.obs <- vl_posterior$data_link(preds$mu.obs)

  # Convert predicted variance (via quantiles) to data scale
  data_preds$data_pred_upper_quantile = vl_posterior$data_link(qnorm(p=.95, mean = preds$mu.pred,
                                                                sd = sqrt(preds$var.pred)))
  data_preds$data_pred_lower_quantile = vl_posterior$data_link(qnorm(p=.05, mean = preds$mu.pred,
                                                                sd = sqrt(preds$var.pred)))
  data_preds$data_obs_upper_quantiles = vl_posterior$data_link(qnorm(p=.95, mean = preds$mu.obs,
                                                                sd = sqrt(preds$var.obs)))
  data_preds$data_obs_lower_quantiles = vl_posterior$data_link(qnorm(p=.05, mean = preds$mu.obs,
                                                                sd = sqrt(preds$var.obs)))

  return(c(preds, data_preds))
}



######  compute V for posterior inference   #######

U2V=function(U.obj){

  U.y=U.obj$U[U.obj$latent,]

  if(U.obj$ord.pred!='obspred'){

    W=Matrix::tcrossprod(U.y)
    W.rev=rev.mat(W)
    V.ord=t(chol(W.rev))

  } else {  # for obspred ordering

    last.obs=max(which(!U.obj$latent))
    latents.before=sum(U.obj$latent[1:last.obs])
    latents.after=sum(U.obj$latent[-(1:last.obs)])

    # pred columns are unchanged
    V.pr=rev.mat(U.y[,(last.obs+1):ncol(U.y),drop=FALSE])

    # have to compute cholesky for obs block
    U.oo=U.y[1:latents.before,1:last.obs]
    A=Matrix::tcrossprod(U.oo)
    A.rev=rev.mat(A)
    V.oor=t(chol(A.rev))

    # combine the blocks into one matrix
    zeromat.sparse=sparseMatrix(c(),c(),dims=c(latents.after,latents.before))
    V.or=rbind(zeromat.sparse,V.oor)
    V.ord=as(cbind(V.pr,V.or),'dtCMatrix')

  }

  return(V.ord)
}




######  posterior mean (predictions)   #######

vecchia_mean=function(z,vecchia.approx,U.obj,V.ord){

  U=U.obj$U

  # compute entire posterior mean vector
  z.ord=z[U.obj$ord.z]
  z1=Matrix::crossprod(U[!U.obj$latent,],z.ord)
  z2=as.numeric(U[U.obj$latent,]%*%z1)
  temp=solve(V.ord,rev(z2))
  mu.rev=-solve(Matrix::t(V.ord),temp)
  mu.ord=rev(mu.rev)

  # for zero nugget, observations are posterior means
  if(length(U.obj$zero.nugg)>0){
    obs.zero=z.ord[U.obj$zero.nugg$inds.z]
    mu.ord=c(mu.ord,obs.zero)
  }

  # extract obs and pred parts; return to original ordering
  orig.order=order(U.obj$ord)
  mu=mu.ord[orig.order]
  if(vecchia.approx$cond.yz=='zy'){
    n.o=length(z)
    mu.obs=mu[n.o+(1:n.o)]
    mu.pred=mu[(2*n.o+1):length(mu)]
  } else {
    obs.orig=U.obj$obs[orig.order]
    mu.obs=mu[obs.orig]
    mu.pred=mu[!obs.orig]
  }

  return(list(mu.obs=mu.obs,mu.pred=mu.pred))
}



######  linear combination   #######

#' linear combination of predictions
#' compute the distribution of a linear combination Hy
#' @param H: sparse matrix with n.all columns specifying the linear combination
#' @param vecchia.approx: a vecchia object as generated by vecchia_specify()
#' @param V.ord: ordered V matrix from vecchia_prediction() or U2V()
#' @param cov.mat: logical TRUE or FALSE -- should the entire covariance matrix be returned (only do if H has a small number of rows)
#'
#' @return Variance of linear combination of predictions.
#' @examples
#' z=rnorm(5); locs=matrix(1:5,ncol=1); vecchia_specify=function(locs,m=5,locs.pred=(1:5)+.5)
#' preds=vecchia_prediction=function(z,vecchia.approx,covparms=c(1,2,.5),nuggets=.2)
#' H=sparseMatrix(i=rep(1,n.p),j=n+(1:n.p),x=1/n.p)
#' vecchia_lincomb(H,vecchia.approx,preds$V.ord,cov.mat=TRUE)
#' @export

vecchia_lincomb=function(H,U.obj,V.ord,cov.mat=FALSE) {
  ord=U.obj$ord
  if(length(U.obj$zero.nugg)>0){
    ord=order(order(ord[1:(length(ord)-length(U.obj$zero.nugg$inds.U))]))
  }
  if(U.obj$cond.yz=='zy'){
    H=cbind(sparseMatrix(c(),c(),dims=c(nrow(H),length(U.obj$ord.z))),H)
  }
  H.tt=Matrix::t(H[,rev(ord),drop=FALSE])
  temp=Matrix::solve(V.ord,H.tt)
  if(cov.mat){
    lincomb.cov=as.matrix(Matrix::t(temp)%*%temp)
    return(lincomb.cov)
  } else {
    lincomb.vars=as.numeric(Matrix::t(temp*temp)%*%rep(1,ncol(H)))
    return(lincomb.vars)
  }
}



######  selected inverse of a sparse matrix   #######

SelInv=function(cholmat){
  n.all=nrow(cholmat)
  Takahashi_Davis(Q=sparseMatrix(c(),c(),dims=c(n.all,1)),
                  cholQp=cholmat,P=sparseMatrix(i=1:n.all,j=1:n.all,x=1))
}



######  posterior variances   #######

vecchia_var=function(U.obj,V.ord,exact=FALSE){

  # compute selected inverse and extract variances
  inv.sparse=SelInv(V.ord)
  vars.ord=rev(Matrix::diag(inv.sparse))

  # for zero nugget, add zero variances
  if(length(U.obj$zero.nugg)>0){
    vars.ord=c(vars.ord,rep(0,length(U.obj$zero.nugg$inds.z)))
  }

  # return to original ordering
  orig.order=order(U.obj$ord)
  vars=vars.ord[orig.order]


  ### extract obs and pred variances
  if(U.obj$cond.yz!='zy'){

    obs.orig=U.obj$obs[orig.order]
    vars.obs=vars[obs.orig]
    if(sum(!obs.orig)>0) {
      # if exact prediction variances desired, compute using lincomb
      if(exact & U.obj$ord.pred=='obspred'){
        n.p=sum(!U.obj$obs)
        n=nrow(V.ord)-n.p
        H=sparseMatrix(i=1:(n+n.p),j=1:(n+n.p),x=1)[(n+1):(n+n.p),]
        vars.pred=vecchia_lincomb(H,U.obj,V.ord)
      } else vars.pred=vars[!obs.orig]
    } else vars.pred=c()

  } else {

    n=length(U.obj$ord.z)
    n.p=length(vars)-2*n
    if(!exact){
      vars.obs=vars[n+(1:n)]
      vars.pred= (if(n.p>0) vars[2*n+(1:n.p)] else c())
    } else {
      H=sparseMatrix(i=1:(n+n.p),j=1:(n+n.p),x=1)
      vars.exact=vecchia_lincomb(H,U.obj,V.ord)
      vars.obs=vars.exact[1:n]
      vars.pred= (if(n.p>0) vars.exact[n+(1:n.p)] else c())
    }

  }

  return(list(vars.obs=vars.obs,vars.pred=vars.pred))
}



######  compute covariance matrix from V.ord   #######
# do not do this for large n or n.p!!!

#' compute covariance matrix from V.ord
#' Do not run this function for large n or n.p!!!
#' @param preds: Object returned by vecchia_prediction()
#'
#' @return Covariance matrix at all locations in original order
#' @examples
#' z=rnorm(5); locs=matrix(1:5,ncol=1); vecchia_specify=function(z,locs,m=5,locs.pred=(1:5)+.5)
#' preds=vecchia_prediction(vecchia.approx,covparms=c(1,2,.5),nuggets=.2)
#' V2covmat=function(preds)
#' @export

V2covmat=function(preds){

  # compute joint covariance matrix
  Sigma.ord=solve(as.matrix(rev.mat(preds$V.ord%*%Matrix::t(preds$V.ord))))

  # for zero nugget, add zero rows/columns
  if(length(preds$U.obj$zero.nugg)>0){
    k=nrow(Sigma.ord)
    l=length(preds$U.obj$zero.nugg$inds.z)
    Sigma.ord=rbind(cbind(Sigma.ord,matrix(0,nrow=k,ncol=l)),
                    matrix(0,nrow=l,ncol=k+l))
  }

  # return to original ordering
  orig.order=order(preds$U.obj$ord)
  Sigma=Sigma.ord[orig.order,orig.order]

  # extract parts corresponding to obs and pred locs
  if(preds$U.obj$cond.yz=='zy'){
    n.o=length(z)
    Sigma.obs=Sigma[n.o+(1:n.o),n.o+(1:n.o)]
    Sigma.pred=Sigma[(2*n.o+1):nrow(Sigma),(2*n.o+1):nrow(Sigma)]
  } else {
    obs.orig=preds$U.obj$obs[orig.order]
    Sigma.obs=Sigma[obs.orig,obs.orig]
    Sigma.pred=Sigma[!obs.orig,!obs.orig]
  }

  return(list(Sigma.obs=Sigma.obs,Sigma.pred=Sigma.pred))
}
